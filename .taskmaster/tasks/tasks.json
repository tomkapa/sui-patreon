{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Smart Contract - Profile Management",
        "description": "Implement Move smart contract for creator profiles with NFT-based identity, creation, and update functionality",
        "details": "Create contracts/sources/profile.move module with:\n\n1. Struct Definitions:\n   - CreatorProfile (has key): id, creator address, name, bio, avatar_url, created_at\n   - ProfileCreated event (has copy, drop): profile_id, creator, name, timestamp\n\n2. Functions:\n   - create_profile(name, bio, avatar_url, ctx): Creates profile NFT, emits event, transfers to sender\n   - update_profile(profile, bio, avatar_url): Updates mutable fields, requires ownership\n\n3. Implementation Details:\n   - Use sui::object for UID/ID management\n   - Use sui::tx_context for sender/timestamp\n   - Verify ownership in update function using ctx\n   - Emit ProfileCreated event for indexer\n   - Profile is owned object (key ability only)\n\n4. Move best practices:\n   - Use entry functions for external calls\n   - Proper ability declarations (key for NFTs)\n   - Event emission for off-chain indexing\n   - Timestamp using tx_context::epoch_timestamp_ms",
        "testStrategy": "1. Unit tests in contracts/tests/profile_tests.move:\n   - test_create_profile_success: Verify profile creation with valid inputs\n   - test_update_profile_success: Verify owner can update bio/avatar\n   - test_update_profile_unauthorized: Verify non-owner cannot update (should abort)\n   - test_event_emission: Verify ProfileCreated event emitted with correct data\n\n2. Integration tests:\n   - Deploy to localnet using sui move build && sui client publish\n   - Call create_profile via CLI: sui client call --function create_profile --args \"TestCreator\" \"Test bio\" \"https://avatar.url\"\n   - Verify profile NFT appears in creator's objects\n   - Attempt update from different address (should fail)\n\n3. Verification:\n   - Check ProfileCreated event in transaction effects\n   - Query owned objects and verify CreatorProfile exists\n   - Validate all fields match input parameters",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "2",
        "title": "Smart Contract - Subscription Tiers",
        "description": "Implement Move smart contract for creating and managing subscription tiers with pricing and activation controls",
        "details": "Create contracts/sources/subscription.move module:\n\n1. Struct Definitions:\n   - SubscriptionTier (has key, store): id, creator address, name, description, price_monthly (u64 in MIST), is_active (bool)\n   - TierCreated event (has copy, drop): tier_id, creator, name, price\n\n2. Functions:\n   - create_tier(name, description, price_monthly, ctx): Creates shared tier object\n   - update_tier_price(tier, new_price, ctx): Updates price (creator only)\n   - deactivate_tier(tier, ctx): Sets is_active to false (creator only)\n\n3. Implementation:\n   - Use sui::transfer::share_object for tier (multiple interactions)\n   - Ownership verification: assert!(tier.creator == tx_context::sender(ctx), ERROR_NOT_CREATOR)\n   - Price in MIST: 1 SUI = 1_000_000_000 MIST\n   - Store creation timestamp\n\n4. Shared object pattern:\n   - Tier must be shared (not owned) for concurrent purchases\n   - Mutable references for updates\n   - Creator address stored for authorization",
        "testStrategy": "1. Unit tests:\n   - test_create_tier_valid_price: Create tier with price > 0\n   - test_update_price_by_creator: Verify creator can change price\n   - test_update_price_unauthorized: Non-creator update fails\n   - test_deactivate_tier: Verify is_active becomes false\n   - test_inactive_tier_remains_accessible: Deactivated tier still queryable\n\n2. Integration tests:\n   - Deploy and create tier: sui client call --function create_tier --args \"Gold Tier\" \"Premium content\" 5000000000\n   - Verify tier is shared object (not in owned objects)\n   - Update price from creator wallet\n   - Attempt update from different wallet (expect failure)\n\n3. Price conversion validation:\n   - Test with fractional SUI (e.g., 0.5 SUI = 500000000 MIST)\n   - Verify large prices (100 SUI) handled correctly\n   - Check minimum price enforcement if implemented",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Smart Contract - Subscription Purchase & Payment",
        "description": "Implement subscription purchase flow with SUI payment processing, NFT minting, and 30-day validity",
        "details": "Extend contracts/sources/subscription.move:\n\n1. Additional Structs:\n   - ActiveSubscription (has key, store): id, subscriber, creator, tier_id, tier_name, started_at, expires_at\n   - SubscriptionPurchased event: subscription_id, subscriber, creator, tier_id, amount, expires_at\n\n2. purchase_subscription function:\n   ```move\n   public entry fun purchase_subscription(\n       tier: &SubscriptionTier,\n       payment: Coin<SUI>,\n       ctx: &mut TxContext\n   ) {\n       // Verify tier is active\n       assert!(tier.is_active, ERROR_TIER_INACTIVE);\n       \n       // Verify payment amount >= tier.price_monthly\n       assert!(coin::value(&payment) >= tier.price_monthly, ERROR_INSUFFICIENT_PAYMENT);\n       \n       // Calculate expiration (current epoch + 30 days in ms)\n       let started_at = tx_context::epoch_timestamp_ms(ctx);\n       let expires_at = started_at + (30 * 24 * 60 * 60 * 1000);\n       \n       // Create subscription NFT\n       let subscription = ActiveSubscription {\n           id: object::new(ctx),\n           subscriber: tx_context::sender(ctx),\n           creator: tier.creator,\n           tier_id: object::id(tier),\n           tier_name: tier.name,\n           started_at,\n           expires_at,\n       };\n       \n       // Transfer payment to creator\n       transfer::public_transfer(payment, tier.creator);\n       \n       // Transfer subscription NFT to subscriber\n       transfer::transfer(subscription, tx_context::sender(ctx));\n       \n       // Emit event\n       event::emit(SubscriptionPurchased { ... });\n   }\n   ```\n\n3. Helper function:\n   - is_active(sub, current_epoch): Returns bool if expires_at >= current_epoch",
        "testStrategy": "1. Unit tests:\n   - test_purchase_exact_amount: Purchase with exact tier price\n   - test_purchase_overpayment: Purchase with amount > price (should succeed)\n   - test_purchase_underpayment: Should abort with ERROR_INSUFFICIENT_PAYMENT\n   - test_purchase_inactive_tier: Should abort with ERROR_TIER_INACTIVE\n   - test_expiration_calculation: Verify expires_at = started_at + 30 days\n   - test_is_active_unexpired: Returns true for valid subscription\n   - test_is_active_expired: Returns false after expiration\n\n2. Integration tests:\n   - Create tier with 1 SUI price\n   - Split gas coin: [coin] = tx.splitCoins(tx.gas, [1000000000])\n   - Call purchase_subscription with coin\n   - Verify subscriber receives subscription NFT\n   - Verify creator receives payment (check balance increase)\n   - Check SubscriptionPurchased event emission\n\n3. Payment flow validation:\n   - Test with multiple denominations\n   - Verify creator balance increases by exact tier price\n   - Ensure subscription NFT contains correct tier_id and creator address",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Smart Contract - Content Registry & Access Control",
        "description": "Implement content metadata registry with Walrus blob IDs and tier-based access requirements",
        "details": "Create contracts/sources/content.move module:\n\n1. Struct Definitions:\n   - Content (has key): id, creator, title, description, content_type, walrus_blob_id, preview_blob_id, required_tier_ids (vector<ID>), created_at, is_public\n   - ContentCreated event: content_id, creator, title, tier_ids\n\n2. create_content function:\n   ```move\n   public entry fun create_content(\n       title: String,\n       description: String,\n       content_type: String,\n       walrus_blob_id: String,\n       preview_blob_id: String,\n       required_tier_ids: vector<ID>,\n       is_public: bool,\n       ctx: &mut TxContext\n   ) {\n       let content = Content {\n           id: object::new(ctx),\n           creator: tx_context::sender(ctx),\n           title,\n           description,\n           content_type,\n           walrus_blob_id,\n           preview_blob_id,\n           required_tier_ids,\n           created_at: tx_context::epoch_timestamp_ms(ctx),\n           is_public,\n       };\n       \n       transfer::share_object(content);\n       event::emit(ContentCreated { ... });\n   }\n   ```\n\n3. Implementation notes:\n   - Content is shared object (public access for metadata)\n   - Walrus blob IDs stored as strings\n   - Support vector of tier IDs for multi-tier access\n   - Public content has empty required_tier_ids\n   - Preview blob for free samples",
        "testStrategy": "1. Unit tests:\n   - test_create_content_with_tiers: Create content requiring specific tiers\n   - test_create_public_content: Create with is_public=true, empty tier_ids\n   - test_multiple_tier_requirements: Content requiring 2+ tiers\n   - test_event_emission: Verify ContentCreated event data\n   - test_walrus_blob_id_storage: Verify blob IDs stored correctly\n\n2. Integration tests:\n   - Upload file to Walrus testnet, get blob_id\n   - Create tier(s) and save tier object IDs\n   - Call create_content with tier IDs in required_tier_ids vector\n   - Verify content is shared object (accessible to all)\n   - Query content and verify all fields match\n   - Test public content creation (no tiers required)\n\n3. Access pattern validation:\n   - Create content with specific tier requirements\n   - Verify metadata readable without subscription\n   - Validate tier_ids vector contains correct object IDs\n   - Test content_type field for different media types",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Smart Contract - Access Verification for Seal Integration",
        "description": "Implement on-chain access verification function for subscription-gated content decryption",
        "details": "Extend contracts/sources/content.move:\n\n1. Access verification logic:\n   ```move\n   use creator_platform::subscription::{ActiveSubscription};\n   use std::vector;\n   \n   public fun verify_access(\n       content: &Content,\n       subscription: &ActiveSubscription,\n       ctx: &TxContext\n   ): bool {\n       // Public content always accessible\n       if (content.is_public) {\n           return true\n       };\n       \n       // Check subscription not expired\n       let current_time = tx_context::epoch_timestamp_ms(ctx);\n       if (subscription.expires_at < current_time) {\n           return false\n       };\n       \n       // Check subscription tier matches content requirements\n       let tier_id = subscription.tier_id;\n       if (vector::contains(&content.required_tier_ids, &tier_id)) {\n           return true\n       };\n       \n       false\n   }\n   \n   // Entry function for Seal approval\n   public entry fun seal_approve(\n       content: &Content,\n       subscription: &ActiveSubscription,\n       ctx: &TxContext\n   ) {\n       assert!(verify_access(content, subscription, ctx), ERROR_ACCESS_DENIED);\n   }\n   ```\n\n2. Integration with Seal:\n   - seal_approve called by Seal before decryption\n   - Transaction must succeed for decryption approval\n   - Subscription NFT passed as proof of access\n\n3. Error codes:\n   - ERROR_ACCESS_DENIED: Subscription invalid or expired\n   - ERROR_WRONG_TIER: Subscription tier not in required_tier_ids",
        "testStrategy": "1. Unit tests:\n   - test_verify_public_content: Always returns true for is_public=true\n   - test_verify_valid_subscription: Returns true for active sub with correct tier\n   - test_verify_expired_subscription: Returns false when expires_at < current_time\n   - test_verify_wrong_tier: Returns false when tier_id not in required_tier_ids\n   - test_verify_multiple_tiers: Returns true if sub tier matches any in vector\n   - test_seal_approve_success: Transaction succeeds with valid access\n   - test_seal_approve_failure: Transaction aborts with ERROR_ACCESS_DENIED\n\n2. Integration tests:\n   - Create content with tier requirement\n   - Purchase subscription for that tier\n   - Call verify_access - should return true\n   - Wait for expiration or use different tier - should return false\n   - Test seal_approve entry function with PTB\n\n3. Seal integration test:\n   - Mock Seal decryption policy\n   - Call seal_approve with valid subscription NFT\n   - Verify transaction succeeds\n   - Attempt with invalid/expired subscription\n   - Verify transaction fails with appropriate error",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Backend - Express Server with Bun Runtime",
        "description": "Set up Express.js backend with TypeScript, CORS, health checks, and error handling optimized for Bun",
        "details": "Create backend/src/index.ts:\n\n1. Dependencies:\n   - express, cors, dotenv\n   - @types/express, @types/cors for TypeScript\n\n2. Server configuration:\n   - Port: process.env.PORT || 3001\n   - CORS: origin from FRONTEND_URL env (default: http://localhost:3000)\n   - Body parsing: 50MB limit for file uploads\n   - JSON and URL-encoded body support\n\n3. Middleware stack:\n   - cors({ origin, credentials: true })\n   - express.json({ limit: '50mb' })\n   - express.urlencoded({ extended: true, limit: '50mb' })\n\n4. Routes:\n   - GET /health: Returns { status: 'ok', runtime: 'bun', timestamp, version }\n\n5. Error handler:\n   - Global error middleware\n   - Log errors to console\n   - Return 500 with error message\n\n6. Environment variables (.env):\n   - PORT=3001\n   - FRONTEND_URL=http://localhost:3000\n   - DATABASE_URL (for Prisma)\n   - PACKAGE_ID (Sui contract)\n   - WALRUS_PUBLISHER_URL\n   - WALRUS_AGGREGATOR_URL\n\n7. Package.json scripts:\n   - \"dev\": \"bun --hot src/index.ts\"\n   - \"build\": \"bun build src/index.ts --outdir dist\"\n   - \"start\": \"bun dist/index.js\"",
        "testStrategy": "1. Manual testing:\n   - bun install dependencies\n   - bun run dev\n   - curl http://localhost:3001/health (expect 200 with JSON)\n   - Verify CORS headers with frontend origin\n   - Test 50MB file upload limit\n\n2. Unit tests (using bun:test):\n   - test_health_endpoint: Verify response structure\n   - test_cors_enabled: Check Access-Control-Allow-Origin header\n   - test_large_payload: Send 40MB JSON (should succeed)\n   - test_error_handler: Trigger error, verify 500 response\n\n3. Integration checks:\n   - Start server and verify no errors\n   - Check Bun version in health response\n   - Test hot reload (modify file, verify restart)\n   - Validate all env vars loaded correctly\n\n4. Performance baseline:\n   - Measure startup time (<100ms with Bun)\n   - Test concurrent requests (100 simultaneous)\n   - Verify memory usage stays reasonable",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-17T17:20:05.969Z"
      },
      {
        "id": "7",
        "title": "Backend - PostgreSQL Database Schema with Prisma ORM",
        "description": "Design and implement normalized database schema for creators, tiers, subscriptions, and content with proper indexing",
        "details": "Create backend/prisma/schema.prisma:\n\n1. Models:\n   - Creator: id (UUID), address (unique), profileId (unique), name (unique), bio, avatarUrl, timestamps\n   - Tier: id (UUID), tierId (Sui object ID), creatorId, name, description, price (BigInt), isActive, createdAt\n   - Subscription: id (UUID), subscriptionId (Sui object ID), subscriber (address), tierId, startsAt, expiresAt, isActive, createdAt\n   - Content: id (UUID), contentId (Sui object ID), creatorId, title, description, contentType, walrusBlobId, previewBlobId, isPublic, createdAt\n   - ContentTier: junction table for many-to-many (contentId, tierId as composite PK)\n\n2. Relationships:\n   - Creator → Tier (one-to-many)\n   - Creator → Content (one-to-many)\n   - Tier → Subscription (one-to-many)\n   - Content ↔ Tier (many-to-many via ContentTier)\n\n3. Indexes:\n   - Creator: @@index([address]), @@index([name])\n   - Tier: @@index([creatorId]), @@index([tierId])\n   - Subscription: @@index([subscriber]), @@index([subscriptionId])\n   - Content: @@index([creatorId]), @@index([contentId])\n\n4. Data types:\n   - Use BigInt for price (MIST precision)\n   - Use String for addresses and object IDs\n   - Use DateTime for timestamps\n   - Use Boolean for flags\n\n5. Commands:\n   - bunx prisma migrate dev --name init\n   - bunx prisma generate\n   - bunx prisma studio (for GUI)\n\n6. Environment:\n   - DATABASE_URL=\"postgresql://user:password@localhost:5432/creatorchain?schema=public\"",
        "testStrategy": "1. Migration testing:\n   - Run prisma migrate dev\n   - Verify migration files created in prisma/migrations/\n   - Check PostgreSQL database for tables\n   - Validate all columns, types, and constraints\n   - Verify indexes created (use \\d+ table_name in psql)\n\n2. Schema validation:\n   - bunx prisma validate\n   - bunx prisma format (check formatting)\n   - Verify relationships with prisma studio\n   - Test foreign key constraints\n\n3. CRUD operations:\n   - Create test script: backend/prisma/seed.ts\n   - Insert test creator\n   - Create tier for creator\n   - Insert content with tier relations\n   - Query with includes to verify relationships\n   - Test cascade deletes (if configured)\n\n4. Performance tests:\n   - Insert 1000 creators\n   - Query by indexed field (address) - should be <10ms\n   - Query with multiple joins (creator + tiers + content)\n   - Verify query plans use indexes (EXPLAIN ANALYZE)\n\n5. Data integrity:\n   - Test unique constraints (duplicate address should fail)\n   - Test required fields (null values should fail)\n   - Validate BigInt handling for large prices",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-17T17:36:54.054Z"
      },
      {
        "id": "8",
        "title": "Backend - Sui Event Indexer Service",
        "description": "Build real-time event listener that subscribes to smart contract events and syncs data to PostgreSQL",
        "details": "Create backend/src/indexer.ts:\n\n1. Dependencies:\n   - @mysten/sui.js/client (SuiClient)\n   - @prisma/client (PrismaClient)\n\n2. Setup:\n   - SuiClient with testnet URL\n   - PrismaClient instance\n   - PACKAGE_ID from environment\n\n3. Event subscriptions:\n   a) ProfileCreated:\n      - Filter: MoveEventType `${PACKAGE_ID}::profile::ProfileCreated`\n      - Parse: profile_id, creator, name\n      - Upsert Creator (where: address, update: profileId/name, create: all fields)\n   \n   b) TierCreated:\n      - Filter: MoveEventType `${PACKAGE_ID}::subscription::TierCreated`\n      - Parse: tier_id, creator, name, price\n      - Find creator by address\n      - Create Tier with creatorId relation\n   \n   c) SubscriptionPurchased:\n      - Filter: MoveEventType `${PACKAGE_ID}::subscription::SubscriptionPurchased`\n      - Parse: subscription_id, subscriber, tier_id, expires_at\n      - Find tier by tierId\n      - Create Subscription with relations\n   \n   d) ContentCreated:\n      - Filter: MoveEventType `${PACKAGE_ID}::content::ContentCreated`\n      - Parse: content_id, creator, title, tier_ids[]\n      - Find creator by address\n      - Create Content\n      - Create ContentTier entries for each tier_id\n\n4. Error handling:\n   - Try-catch for each event handler\n   - Log errors with context\n   - Continue processing on individual failures\n   - Reconnect logic for lost connections\n\n5. Logging:\n   - Startup message with package ID\n   - Event received logs\n   - Success logs with entity name\n   - Error logs with full details\n\n6. Run script:\n   - package.json: \"dev:indexer\": \"bun src/indexer.ts\"",
        "testStrategy": "1. Unit tests:\n   - Mock SuiClient.subscribeEvent\n   - Test each event handler with sample event data\n   - Verify correct Prisma upsert/create calls\n   - Test error handling for missing creator\n\n2. Integration tests:\n   - Deploy contracts to localnet/testnet\n   - Start indexer service\n   - Trigger each event type via smart contract calls:\n     * Create profile → check Creator table\n     * Create tier → check Tier table with correct creatorId\n     * Purchase subscription → check Subscription table\n     * Create content → check Content + ContentTier tables\n   - Verify data consistency across tables\n\n3. Real-time sync validation:\n   - Submit multiple transactions rapidly\n   - Verify all events indexed\n   - Check no duplicate entries (upsert working)\n   - Validate timestamps match chain\n\n4. Failure scenarios:\n   - Kill indexer mid-sync → restart → verify catch-up\n   - Database connection loss → verify graceful handling\n   - Invalid event data → verify error logged, other events continue\n\n5. Performance:\n   - Index 100 events → measure time and memory\n   - Check database connection pooling\n   - Verify no memory leaks over 1000+ events",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Backend - Walrus Storage Service Integration",
        "description": "Build service class for uploading, downloading, and managing files on Walrus decentralized storage",
        "details": "Create backend/src/services/storage.service.ts:\n\n1. WalrusStorage class methods:\n   \n   a) upload(data: Buffer, epochs: number = 100): Promise<string>\n      - PUT to ${WALRUS_PUBLISHER}/v1/store?epochs={epochs}\n      - Headers: Content-Type: application/octet-stream\n      - Body: raw buffer data\n      - Parse response: newlyCreated.blobObject.blobId OR alreadyCertified.blobId\n      - Return blob ID string\n      - maxBodyLength/maxContentLength: Infinity\n   \n   b) download(blobId: string): Promise<Buffer>\n      - GET from ${WALRUS_AGGREGATOR}/v1/{blobId}\n      - responseType: 'arraybuffer'\n      - Convert to Buffer and return\n   \n   c) getUrl(blobId: string): string\n      - Return ${WALRUS_AGGREGATOR}/v1/{blobId}\n   \n   d) exists(blobId: string): Promise<boolean>\n      - HEAD request to aggregator URL\n      - Return true if 200, false if error\n\n2. Configuration:\n   - WALRUS_PUBLISHER_URL: https://publisher.walrus-testnet.walrus.space\n   - WALRUS_AGGREGATOR_URL: https://aggregator.walrus-testnet.walrus.space\n   - Load from env with defaults\n\n3. Error handling:\n   - Try-catch all HTTP requests\n   - Throw descriptive errors: \"Walrus upload failed: {message}\"\n   - Log operations with size info\n\n4. Export singleton:\n   - export const walrus = new WalrusStorage();\n\n5. Logging:\n   - Log upload start with size\n   - Log success with blob ID\n   - Log download start\n   - Log errors with context",
        "testStrategy": "1. Unit tests:\n   - Mock axios requests\n   - test_upload_success: Verify correct URL, headers, body\n   - test_upload_returns_blob_id: Parse response correctly\n   - test_download_returns_buffer: Verify arraybuffer conversion\n   - test_get_url_format: Verify URL construction\n   - test_exists_true: HEAD returns 200\n   - test_exists_false: HEAD returns 404\n\n2. Integration tests (requires Walrus testnet):\n   - Upload small file (1KB): const blobId = await walrus.upload(Buffer.from('test'))\n   - Download same blob: const data = await walrus.download(blobId)\n   - Verify data matches original\n   - Test large file (10MB)\n   - Test exists() with valid/invalid blob IDs\n   - Verify getUrl() returns accessible URL\n\n3. Error scenarios:\n   - Network timeout → verify error thrown\n   - Invalid blob ID → verify download fails gracefully\n   - Malformed response → verify parsing error handled\n\n4. Performance:\n   - Upload 100MB file → measure time\n   - Download 100MB file → measure time\n   - Concurrent uploads (10 files) → verify no failures\n\n5. Edge cases:\n   - Empty buffer upload\n   - Special characters in blob ID\n   - Very long epoch value",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-17T17:31:27.849Z"
      },
      {
        "id": "10",
        "title": "Backend - Seal Encryption Service Integration",
        "description": "Implement client-side encryption/decryption service using Mysten Labs Seal SDK for policy-based access control",
        "details": "Create backend/src/services/encryption.service.ts:\n\n1. SealEncryption class:\n   - Private member: seal (SealClient instance)\n   - Constructor: Initialize SealClient with SuiClient and network config\n\n2. Methods:\n   \n   a) encrypt(data: Buffer, policyId: string): Promise<Buffer>\n      - Convert Buffer to Uint8Array\n      - Call seal.encrypt(uint8Data, { policyId })\n      - Return encrypted data as Buffer\n      - Log encryption with data size\n   \n   b) decrypt(encryptedData: Buffer, txDigest: string): Promise<Buffer>\n      - Convert Buffer to Uint8Array\n      - Call seal.decrypt(uint8Data, { txDigest })\n      - Return decrypted data as Buffer\n      - Log decryption with size\n\n3. Configuration:\n   - SuiClient: testnet fullnode URL\n   - SealClient: { suiClient, network: 'testnet' }\n\n4. Error handling:\n   - Try-catch all Seal operations\n   - Throw: \"Seal encryption failed: {message}\"\n   - Throw: \"Seal decryption failed: {message}\"\n\n5. Export singleton:\n   - export const seal = new SealEncryption();\n\n6. Dependencies:\n   - @mystenlabs/seal-sdk\n   - @mysten/sui.js/client\n\n7. Policy management (future):\n   - Store policy IDs per content/tier\n   - Verify transaction approval before decrypt",
        "testStrategy": "1. Unit tests:\n   - Mock SealClient methods\n   - test_encrypt_calls_sdk: Verify encrypt called with correct params\n   - test_decrypt_calls_sdk: Verify decrypt called with txDigest\n   - test_buffer_conversion: Verify Buffer ↔ Uint8Array conversion\n   - test_error_handling: Mock SDK error, verify thrown\n\n2. Integration tests (requires Seal testnet):\n   - Create test policy on Sui testnet\n   - Encrypt test data: const encrypted = await seal.encrypt(Buffer.from('secret'), policyId)\n   - Verify encrypted data differs from original\n   - Create approval transaction on-chain\n   - Decrypt with tx digest: const decrypted = await seal.decrypt(encrypted, txDigest)\n   - Verify decrypted matches original\n\n3. Access control tests:\n   - Encrypt content with policy requiring subscription\n   - Attempt decrypt without approval → should fail\n   - Create subscription and approval tx\n   - Decrypt with valid tx → should succeed\n\n4. Performance:\n   - Encrypt 10MB file → measure time\n   - Decrypt 10MB file → measure time\n   - Compare encrypted vs original size (overhead)\n\n5. Edge cases:\n   - Empty buffer encryption\n   - Invalid policy ID → verify error\n   - Invalid tx digest → verify error\n   - Expired policy → verify behavior",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-17T17:40:55.436Z"
      },
      {
        "id": "11",
        "title": "Backend - Content Upload and Download API Endpoints",
        "description": "Create REST API endpoints for encrypted content upload to Walrus and secure download with decryption",
        "details": "Create backend/src/routes/upload.ts:\n\n1. POST /api/upload endpoint:\n   - Request body: { file: string (base64), contentType: string, policyId: string, encrypt?: boolean }\n   - Decode base64 to Buffer\n   - If encrypt=true: encrypted = await seal.encrypt(fileBuffer, policyId)\n   - Upload to Walrus: blobId = await walrus.upload(dataToUpload)\n   - Response: { success: true, blobId, url, size, encrypted, contentType }\n   - Error handling: 400 for missing file, 500 for processing errors\n\n2. GET /api/download/:blobId endpoint:\n   - Query params: decrypt (boolean), txDigest (string)\n   - Download from Walrus: data = await walrus.download(blobId)\n   - If decrypt=true && txDigest: data = await seal.decrypt(data, txDigest)\n   - Response: binary data with Content-Type: application/octet-stream\n   - Error handling: 404 for missing blob, 500 for decryption errors\n\n3. Middleware:\n   - Body size limit: 50MB (already configured in main app)\n   - CORS headers for cross-origin uploads\n\n4. Logging:\n   - Log upload start with file size\n   - Log encryption/upload steps\n   - Log download requests with blob ID\n   - Log errors with full context\n\n5. Mount in backend/src/index.ts:\n   - import uploadRouter from './routes/upload'\n   - app.use('/api', uploadRouter)\n\n6. Response formats:\n   - Success: JSON with metadata\n   - Error: JSON with { error: string }",
        "testStrategy": "1. Unit tests:\n   - Mock walrus and seal services\n   - test_upload_without_encryption: Verify direct upload\n   - test_upload_with_encryption: Verify seal.encrypt called\n   - test_upload_missing_file: Expect 400\n   - test_download_without_decryption: Verify walrus.download called\n   - test_download_with_decryption: Verify seal.decrypt called\n\n2. Integration tests:\n   - Start backend server\n   - Upload small file (1MB):\n     * Encode to base64\n     * POST to /api/upload\n     * Verify 200 response with blobId\n   - Download without decryption:\n     * GET /api/download/{blobId}\n     * Verify data matches (if not encrypted)\n   - Upload encrypted file:\n     * Include policyId and encrypt=true\n     * Verify encrypted flag in response\n   - Download with decryption:\n     * Include decrypt=true and valid txDigest\n     * Verify data matches original\n\n3. End-to-end tests:\n   - Upload 10MB video file encrypted\n   - Create subscription on-chain\n   - Call seal_approve transaction\n   - Download with tx digest\n   - Verify video plays correctly\n\n4. Error scenarios:\n   - Upload without file → 400\n   - Upload with invalid base64 → 500\n   - Download non-existent blob → 404\n   - Decrypt without txDigest → 500\n   - Decrypt with invalid txDigest → 500\n\n5. Performance:\n   - Upload 50MB file → measure time\n   - Concurrent uploads (10 files) → verify all succeed\n   - Download 50MB file → measure time",
        "priority": "high",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-18T04:36:21.688Z"
      },
      {
        "id": "12",
        "title": "Backend - Creator and Content REST API Endpoints",
        "description": "Build comprehensive CRUD API endpoints for querying creators, tiers, subscriptions, and content with filtering and pagination",
        "details": "Create backend/src/routes/creators.ts:\n\n1. GET /api/creators/:address\n   - Find creator by address\n   - Include: tiers, content (with tiers)\n   - Return 404 if not found\n   - Response: Creator object with relations\n\n2. GET /api/creators\n   - Query params: query (string), limit (number, default 20)\n   - Search creators by name (case-insensitive contains)\n   - Include: tiers\n   - Pagination with limit\n   - Response: Creator[] array\n\n3. GET /api/creators/:address/content\n   - Find creator by address\n   - Query content where creatorId matches\n   - Include: tiers (junction table)\n   - Order by: createdAt desc\n   - Response: Content[] array\n\n4. Additional endpoints to implement:\n   - GET /api/tiers/:tierId - Get tier by Sui object ID\n   - GET /api/subscriptions/:address - Get user's subscriptions\n   - GET /api/content/:contentId - Get content by Sui object ID\n   - GET /api/content/:contentId/access - Check if user has access\n\n5. Error handling:\n   - 404 for not found resources\n   - 500 for database errors\n   - Return JSON: { error: string }\n\n6. Mount in backend/src/index.ts:\n   - import creatorsRouter from './routes/creators'\n   - app.use('/api/creators', creatorsRouter)\n\n7. Response structure:\n   - Consistent JSON format\n   - Include related entities when useful\n   - Transform BigInt to string for JSON serialization",
        "testStrategy": "1. Unit tests:\n   - Mock Prisma client\n   - test_get_creator_by_address: Verify correct query\n   - test_get_creator_not_found: Expect 404\n   - test_search_creators: Verify filter and limit\n   - test_get_creator_content: Verify correct relations\n\n2. Integration tests:\n   - Seed database with test data:\n     * 3 creators with unique addresses\n     * 2 tiers per creator\n     * 5 content items per creator\n     * 2 subscriptions\n   - Test GET /api/creators/:address:\n     * Valid address → 200 with full data\n     * Invalid address → 404\n   - Test GET /api/creators?query=test:\n     * Verify filtered results\n     * Test limit parameter\n   - Test GET /api/creators/:address/content:\n     * Verify content belongs to creator\n     * Verify ordered by date\n\n3. Relationship validation:\n   - Verify creator includes tiers\n   - Verify content includes tier requirements\n   - Verify subscription links to correct tier\n   - Check foreign key integrity\n\n4. Pagination tests:\n   - Query with limit=5 → verify max 5 results\n   - Query with limit=100 → verify capped appropriately\n   - Test offset (if implemented)\n\n5. Performance:\n   - Query with 1000 creators → measure time\n   - Verify indexes used (check query plans)\n   - Test concurrent requests (50 simultaneous)\n\n6. Data serialization:\n   - Verify BigInt price fields serialized correctly\n   - Check date formats (ISO 8601)\n   - Validate no sensitive data exposed",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-11-18T04:26:16.040Z"
      },
      {
        "id": "13",
        "title": "Frontend - Sui Client Configuration and Helpers",
        "description": "Set up Sui SDK client singleton with testnet configuration and utility functions for transaction handling",
        "details": "Create web/lib/sui/client.ts:\n\n1. Sui client setup:\n   - Import: SuiClient, getFullnodeUrl from @mysten/sui.js/client\n   - Export singleton: export const suiClient = new SuiClient({ url: getFullnodeUrl('testnet') })\n   - Export PACKAGE_ID: process.env.NEXT_PUBLIC_PACKAGE_ID!\n\n2. Helper functions:\n   \n   a) extractObjectId(result: any): string | null\n      - Parse transaction result\n      - Get created[0].reference.objectId\n      - Return object ID or null\n   \n   b) getGasObject(address: string)\n      - Call suiClient.getCoins({ owner: address })\n      - Return first coin for gas payment\n\n3. Environment variables (.env.local):\n   - NEXT_PUBLIC_PACKAGE_ID=0x...\n   - NEXT_PUBLIC_GOOGLE_CLIENT_ID=...\n   - NEXT_PUBLIC_REDIRECT_URL=http://localhost:3000/auth/callback\n   - NEXT_PUBLIC_API_URL=http://localhost:3001\n\n4. TypeScript types:\n   - Type-safe wrappers\n   - Import types from @mysten/sui.js\n   - Proper return types for all functions\n\n5. Error handling:\n   - Graceful failures for network issues\n   - Return null instead of throwing where appropriate",
        "testStrategy": "1. Unit tests:\n   - test_sui_client_initialization: Verify client created\n   - test_package_id_loaded: Verify env var loaded\n   - test_extract_object_id_success: Parse valid result\n   - test_extract_object_id_null: Handle missing data\n   - test_get_gas_object: Mock getCoins response\n\n2. Integration tests:\n   - Connect to testnet\n   - Verify getFullnodeUrl returns valid URL\n   - Test getCoins with real address\n   - Verify gas object has correct structure\n\n3. Environment validation:\n   - Check NEXT_PUBLIC_PACKAGE_ID not empty\n   - Validate package ID format (0x...)\n   - Test with missing env vars (should error clearly)\n\n4. Network tests:\n   - Test connection to testnet\n   - Verify RPC methods work\n   - Test timeout handling\n   - Retry logic for failed requests",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Frontend - Smart Contract Interaction Functions",
        "description": "Build TypeScript wrapper functions for all smart contract operations with proper transaction construction",
        "details": "Create web/lib/sui/contracts.ts:\n\n1. createProfile(signer, name, bio, avatarUrl)\n   - TransactionBlock with moveCall\n   - Target: ${PACKAGE_ID}::profile::create_profile\n   - Arguments: tx.pure() for each string\n   - Options: showEffects, showObjectChanges, showEvents\n\n2. createTier(signer, name, description, priceInSui)\n   - Convert SUI to MIST: Math.floor(priceInSui * 1_000_000_000)\n   - Target: ${PACKAGE_ID}::subscription::create_tier\n   - Arguments: strings + price as string\n\n3. purchaseSubscription(signer, tierObjectId, priceInSui)\n   - Split gas coin: [coin] = tx.splitCoins(tx.gas, [priceInMist])\n   - Target: ${PACKAGE_ID}::subscription::purchase_subscription\n   - Arguments: tx.object(tierObjectId), coin\n\n4. Query functions:\n   \n   a) getCreatorProfile(address)\n      - suiClient.getOwnedObjects\n      - Filter: StructType ${PACKAGE_ID}::profile::CreatorProfile\n      - Options: showContent, showType\n      - Return first object\n   \n   b) getSubscriptions(address)\n      - Filter: StructType ${PACKAGE_ID}::subscription::ActiveSubscription\n      - Return all objects\n\n5. Error handling:\n   - Try-catch all operations\n   - Parse error messages\n   - Return user-friendly errors\n\n6. Type definitions:\n   - Define interfaces for parsed objects\n   - CreatorProfileData, SubscriptionData, etc.",
        "testStrategy": "1. Unit tests:\n   - Mock TransactionBlock and SuiClient\n   - test_create_profile_tx: Verify correct moveCall\n   - test_create_tier_price_conversion: 1 SUI = 1_000_000_000 MIST\n   - test_purchase_subscription_coin_split: Verify splitCoins called\n   - test_get_creator_profile_filter: Verify correct struct type\n\n2. Integration tests (testnet):\n   - Connect wallet (test keypair)\n   - Create profile:\n     * Call createProfile\n     * Wait for transaction\n     * Verify profile created with getCreatorProfile\n   - Create tier:\n     * Call createTier with 1 SUI\n     * Extract tier object ID\n     * Query tier object\n   - Purchase subscription:\n     * Call purchaseSubscription\n     * Verify subscription NFT received\n     * Check creator balance increased\n\n3. Transaction validation:\n   - Verify gas estimation\n   - Check transaction effects\n   - Validate object changes\n   - Verify events emitted\n\n4. Error scenarios:\n   - Insufficient gas → proper error\n   - Invalid object ID → proper error\n   - Wrong arguments → proper error\n\n5. Query tests:\n   - Query address with no objects → empty array\n   - Query with multiple profiles → return all\n   - Verify content parsing correct",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Frontend - zkLogin Authentication Hook",
        "description": "Implement React hook for Google OAuth zkLogin authentication with session management",
        "details": "Create web/hooks/useZkLogin.ts:\n\n1. Hook state:\n   - address: string | null\n   - isLoading: boolean\n   - isAuthenticated: computed from !!address\n\n2. useEffect for session restore:\n   - Check localStorage for 'zklogin_data'\n   - Parse and set address if exists\n\n3. login() function:\n   - Generate Ed25519Keypair (ephemeral)\n   - Generate randomness and nonce\n   - Store in sessionStorage: ephemeral_keypair, randomness, max_epoch\n   - Construct Google OAuth URL:\n     * client_id: GOOGLE_CLIENT_ID\n     * redirect_uri: REDIRECT_URL\n     * response_type: id_token\n     * scope: openid email profile\n     * nonce: generated nonce\n   - Redirect to Google: window.location.href = authUrl\n\n4. handleCallback() function:\n   - Parse hash params for id_token\n   - Use static salt for hackathon: 'hackathon-salt-12345'\n   - Derive address: jwtToAddress(jwt, salt)\n   - Store in localStorage: { address, jwt }\n   - Clear hash from URL\n\n5. logout() function:\n   - Remove localStorage zklogin_data\n   - Clear sessionStorage\n   - Set address to null\n\n6. Return object:\n   - { address, isLoading, isAuthenticated, login, logout, handleCallback }\n\n7. Dependencies:\n   - @mysten/sui.js/keypairs/ed25519\n   - @mysten/zklogin",
        "testStrategy": "1. Unit tests:\n   - test_initial_state: address null, isAuthenticated false\n   - test_session_restore: Mock localStorage, verify address loaded\n   - test_login_generates_keypair: Verify ephemeral key created\n   - test_login_stores_session: Verify sessionStorage set\n   - test_callback_parses_jwt: Mock hash, verify address derived\n   - test_logout_clears_session: Verify localStorage/sessionStorage cleared\n\n2. Integration tests:\n   - Mount component using hook\n   - Call login() → verify redirect URL format\n   - Mock OAuth callback:\n     * Set window.location.hash with test JWT\n     * Call handleCallback()\n     * Verify address set\n     * Verify localStorage updated\n   - Call logout() → verify state cleared\n\n3. OAuth flow test (manual):\n   - Click login button\n   - Complete Google OAuth\n   - Return to callback URL\n   - Verify address displayed\n   - Refresh page → verify session persists\n   - Logout → verify session cleared\n\n4. Edge cases:\n   - Callback without JWT → no error\n   - Invalid JWT → handle gracefully\n   - Multiple login attempts → previous session cleared\n   - Browser back button after login → session maintained\n\n5. Security validation:\n   - Verify nonce uniqueness\n   - Check JWT signature (zkLogin SDK handles)\n   - Validate salt consistency",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "16",
        "title": "Frontend - Full Application UI with Dashboard and Forms",
        "description": "Build complete frontend application with landing page, creator dashboard, profile/tier/content forms, and content discovery using Next.js, React, and shadcn/ui",
        "details": "Create comprehensive frontend application:\n\n1. Components to build:\n   \n   a) web/components/auth/LoginButton.tsx:\n      - Use useZkLogin hook\n      - Show address when authenticated (truncated)\n      - Google OAuth button when not authenticated\n      - Logout button\n      - Loading states\n   \n   b) web/components/creator/CreateProfileForm.tsx:\n      - Form: name, bio, avatarUrl\n      - Call createProfile from contracts.ts\n      - Success/error handling\n      - Form validation\n   \n   c) web/components/creator/CreateTierForm.tsx:\n      - Form: name, description, price (in SUI)\n      - Call createTier\n      - Price input with SUI denomination\n   \n   d) web/components/content/UploadForm.tsx:\n      - File upload input\n      - Title, description fields\n      - Upload to backend API (POST /api/upload)\n      - Call createContent contract\n      - Progress indicators\n   \n   e) web/components/content/ContentCard.tsx:\n      - Display content metadata\n      - Thumbnail/preview\n      - Lock icon for gated content\n      - Subscribe/Access button\n\n2. Pages to create:\n   \n   a) web/app/page.tsx (Landing):\n      - Hero section with value propositions\n      - Feature cards (Ownership, Lower Fees, Censorship Resistant)\n      - CTAs: \"Become a Creator\", \"Discover Creators\"\n      - Navigation with LoginButton\n   \n   b) web/app/creator/dashboard/page.tsx:\n      - Protected route (require authentication)\n      - Profile creation if not exists\n      - Tier management UI\n      - Content upload form\n      - Analytics (subscriber count, revenue)\n   \n   c) web/app/discover/page.tsx:\n      - List creators from API\n      - Search functionality\n      - Creator cards with subscribe button\n   \n   d) web/app/creator/[address]/page.tsx:\n      - Creator profile page\n      - Display tiers\n      - Content grid\n      - Subscribe buttons\n   \n   e) web/app/auth/callback/page.tsx:\n      - Handle OAuth redirect\n      - Call handleCallback from useZkLogin\n      - Loading spinner\n      - Redirect to dashboard\n\n3. Styling:\n   - Use shadcn/ui components (Button, Input, Card, etc.)\n   - Tailwind CSS for layout\n   - Responsive design (mobile-first)\n   - Dark mode support (optional)\n\n4. State management:\n   - React hooks (useState, useEffect)\n   - Context for global state (auth)\n   - React Query for API data (optional)\n\n5. API integration:\n   - axios for HTTP requests\n   - Environment: NEXT_PUBLIC_API_URL\n   - Error handling with toast notifications",
        "testStrategy": "1. Component tests:\n   - Render LoginButton → verify Google button shown\n   - Simulate login → verify address displayed\n   - Test CreateProfileForm submission\n   - Test file upload in UploadForm\n   - Validate form inputs (required fields)\n\n2. Integration tests (Playwright):\n   - Navigate to landing page\n   - Click \"Become a Creator\"\n   - Complete zkLogin flow (mock OAuth)\n   - Create profile\n   - Create tier\n   - Upload content\n   - View content on profile page\n   - Purchase subscription as different user\n   - Access gated content\n\n3. E2E user flows:\n   - Creator onboarding:\n     * Login → Create profile → Create tier → Upload content\n   - Subscriber flow:\n     * Login → Discover creators → View profile → Subscribe → Access content\n\n4. Responsive testing:\n   - Test on mobile viewport (375px)\n   - Test on tablet (768px)\n   - Test on desktop (1920px)\n   - Verify navigation works on all sizes\n\n5. Accessibility:\n   - Keyboard navigation\n   - Screen reader labels\n   - Focus states\n   - ARIA attributes\n\n6. Performance:\n   - Lighthouse score >90\n   - Fast page loads (<2s)\n   - Optimized images\n   - Code splitting",
        "priority": "high",
        "dependencies": [
          "14",
          "15"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-18T04:36:21.694Z",
      "taskCount": 16,
      "completedCount": 11,
      "tags": [
        "master"
      ]
    }
  }
}